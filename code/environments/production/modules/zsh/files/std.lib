#!/bin/zsh

function std/_exit() {
    exit 0
}

trap std/_exit INT TERM EXIT

function std/appendToFunction() {
    local func="$1"
    shift
    functions[$func]=' '"$@"'; '"$functions[$func]"';'
}

function std/defer() {
    std/appendToFunction std/_exit $@
}

function std/root() {
    if [[ "$(whoami)" != "root" ]] ; then
	echo "This script must be run as root!"
	exit 1
    fi
}

function std/onceAround() {
    local lock="$1"

    if [[ -f "$lock" ]]; then
	exit 0
    fi

    touch "$lock"
}

function std/lockAround() {
    local lock="$1"

    std/onceAround "$lock"

    std/defer rm -rf "$lock"
}

function std/ramDiskMounted() {
    mount | grep /mnt/ram | grep -q tmpfs
}

function std/_getGlobalLockPath() {
    local name="$(std/_sanitizePath "$1")"
    local locks="/var/lock/zsh.stdlib"

    # Make sure our lock directory exists.
    mkdir -p "$locks"

    # Make sure everyone can touch the global path
    chmod 777 "$locks"

    # Return the lock path.
    echo "$locks/$name.lock"
}

function std/_getLocalLockPath() {
    local name="$(std/_sanitizePath "$1")"

    # Get the global lock lock name.
    local globalName="$(std/_getGlobalLockPath "$name").$(whoami)"

    # If a global local lock was created at some point, return that now.
    if [[ -e "$globalName" ]]; then
	echo "$globalName"
	return 0
    fi

    # If the RAM disk has not yet been mounted, use a /var/lock lock.
    if ! std/ramDiskMounted; then
	echo "$globalName"
	return 0
    fi

    local locks="/mnt/ram/$(whoami)/Locks"

    # Make sure our lockpath exists.
    mkdir -p "$locks"

    # Return the local lock path name.
    echo "$locks/$name.lock"
}

function std/once() {
    local name="$1"

    std/onceAround "$(std/_getLocalLockPath "$name").once"
}

function std/start() {
    local name="$1"
    local lock="$(std/_getLocalLockPath "$name").pid"

    $@ &
    local ret="$!"
    std/onceAround "$lock"
    echo "$ret" > "$lock"
}

function std/stop() {
    local name="$1"
    local lock="$(std/_getLocalLockPath "$name").pid"

    if [[ ! -f "$lock" ]]; then
        exit
    fi

    kill "$(cat "$lock")"
    rm -rf "$lock"
}

function std/lock() {
    local name="$1"
    std/lockAround "$(std/_getLocalLockPath "$name")"
}

function std/_sanitizePath() {
    local toSanitize="$1"

    echo "$toSanitize" | sed -e 's;/;!;g' -e 's; ;_;g'
}

function std/runDir() {
    local rund="$1"
    shift

    local oldifs="$IFS"
    IFS=$'\n'
    for file in $(ls "$rund"/); do
        IFS="$oldifs"
        "$rund"/"$file" $@
        IFS=$'\n'
    done
    IFS="$oldifs"
}

function std/applyDir() {
    local func="$1"
    shift
    local dir="$1"
    shift

    local oldifs="$IFS"
    IFS=$'\n'
    for file in $(ls "$dir"/); do
        IFS="$oldifs"
        "$func" "$dir"/"$file" $@
        IFS=$'\n'
    done
    IFS="$oldifs"
}

function std/users() {
    cat /etc/passwd | cut -f1 -d:
}
